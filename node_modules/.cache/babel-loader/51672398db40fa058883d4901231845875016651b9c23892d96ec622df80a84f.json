{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"/Users/mc/mc217.github.io/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport OutlineContext from './OutlineContext.js';\nimport OutlineItem from './OutlineItem.js';\nimport { cancelRunningTask } from './shared/utils.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nimport { eventProps, isClassName, isPdf, isRef } from './shared/propTypes.js';\nvar Outline = function Outline(props) {\n  var documentContext = useDocumentContext();\n  invariant(documentContext, 'Unable to find Document context. Did you wrap <Outline /> in <Document />?');\n  var mergedProps = Object.assign(Object.assign({}, documentContext), props);\n  var className = mergedProps.className,\n    inputRef = mergedProps.inputRef,\n    onItemClick = mergedProps.onItemClick,\n    onLoadErrorProps = mergedProps.onLoadError,\n    onLoadSuccessProps = mergedProps.onLoadSuccess,\n    pdf = mergedProps.pdf,\n    otherProps = __rest(mergedProps, [\"className\", \"inputRef\", \"onItemClick\", \"onLoadError\", \"onLoadSuccess\", \"pdf\"]);\n  invariant(pdf, 'Attempted to load an outline, but no document was specified.');\n  var _useResolver = useResolver(),\n    _useResolver2 = _slicedToArray(_useResolver, 2),\n    outlineState = _useResolver2[0],\n    outlineDispatch = _useResolver2[1];\n  var outline = outlineState.value,\n    outlineError = outlineState.error;\n  /**\n   * Called when an outline is read successfully\n   */\n  function onLoadSuccess() {\n    if (typeof outline === 'undefined' || outline === false) {\n      return;\n    }\n    if (onLoadSuccessProps) {\n      onLoadSuccessProps(outline);\n    }\n  }\n  /**\n   * Called when an outline failed to read successfully\n   */\n  function onLoadError() {\n    if (!outlineError) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    warning(false, outlineError.toString());\n    if (onLoadErrorProps) {\n      onLoadErrorProps(outlineError);\n    }\n  }\n  function resetOutline() {\n    outlineDispatch({\n      type: 'RESET'\n    });\n  }\n  useEffect(resetOutline, [outlineDispatch, pdf]);\n  function loadOutline() {\n    if (!pdf) {\n      // Impossible, but TypeScript doesn't know that\n      return;\n    }\n    var cancellable = makeCancellable(pdf.getOutline());\n    var runningTask = cancellable;\n    cancellable.promise.then(function (nextOutline) {\n      outlineDispatch({\n        type: 'RESOLVE',\n        value: nextOutline\n      });\n    }).catch(function (error) {\n      outlineDispatch({\n        type: 'REJECT',\n        error: error\n      });\n    });\n    return function () {\n      return cancelRunningTask(runningTask);\n    };\n  }\n  useEffect(loadOutline, [outlineDispatch, pdf]);\n  useEffect(function () {\n    if (outline === undefined) {\n      return;\n    }\n    if (outline === false) {\n      onLoadError();\n      return;\n    }\n    onLoadSuccess();\n  },\n  // Ommitted callbacks so they are not called every time they change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [outline]);\n  var childContext = useMemo(function () {\n    return {\n      onItemClick: onItemClick\n    };\n  }, [onItemClick]);\n  var eventProps = useMemo(function () {\n    return makeEventProps(otherProps, function () {\n      return outline;\n    });\n  }, [otherProps, outline]);\n  if (!outline) {\n    return null;\n  }\n  function renderOutline() {\n    if (!outline) {\n      return null;\n    }\n    return React.createElement(\"ul\", null, outline.map(function (item, itemIndex) {\n      return React.createElement(OutlineItem, {\n        key: typeof item.dest === 'string' ? item.dest : itemIndex,\n        item: item\n      });\n    }));\n  }\n  return React.createElement(\"div\", Object.assign({\n    className: clsx('react-pdf__Outline', className),\n    ref: inputRef\n  }, eventProps), React.createElement(OutlineContext.Provider, {\n    value: childContext\n  }, renderOutline()));\n};\nOutline.propTypes = Object.assign(Object.assign({}, eventProps), {\n  className: isClassName,\n  inputRef: isRef,\n  onItemClick: PropTypes.func,\n  onLoadError: PropTypes.func,\n  onLoadSuccess: PropTypes.func,\n  pdf: isPdf\n});\nexport default Outline;","map":{"version":3,"names":["_slicedToArray","__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","React","useEffect","useMemo","PropTypes","makeCancellable","makeEventProps","clsx","invariant","warning","OutlineContext","OutlineItem","cancelRunningTask","useDocumentContext","useResolver","eventProps","isClassName","isPdf","isRef","Outline","props","documentContext","mergedProps","assign","className","inputRef","onItemClick","onLoadErrorProps","onLoadError","onLoadSuccessProps","onLoadSuccess","pdf","otherProps","_useResolver","_useResolver2","outlineState","outlineDispatch","outline","value","outlineError","error","toString","resetOutline","type","loadOutline","cancellable","getOutline","runningTask","promise","then","nextOutline","catch","undefined","childContext","renderOutline","createElement","map","item","itemIndex","key","dest","ref","Provider","propTypes","func"],"sources":["/Users/mc/mc217.github.io/node_modules/react-pdf/dist/esm/Outline.js"],"sourcesContent":["'use client';\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport makeCancellable from 'make-cancellable-promise';\nimport makeEventProps from 'make-event-props';\nimport clsx from 'clsx';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport OutlineContext from './OutlineContext.js';\nimport OutlineItem from './OutlineItem.js';\nimport { cancelRunningTask } from './shared/utils.js';\nimport useDocumentContext from './shared/hooks/useDocumentContext.js';\nimport useResolver from './shared/hooks/useResolver.js';\nimport { eventProps, isClassName, isPdf, isRef } from './shared/propTypes.js';\nconst Outline = function Outline(props) {\n    const documentContext = useDocumentContext();\n    invariant(documentContext, 'Unable to find Document context. Did you wrap <Outline /> in <Document />?');\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf } = mergedProps, otherProps = __rest(mergedProps, [\"className\", \"inputRef\", \"onItemClick\", \"onLoadError\", \"onLoadSuccess\", \"pdf\"]);\n    invariant(pdf, 'Attempted to load an outline, but no document was specified.');\n    const [outlineState, outlineDispatch] = useResolver();\n    const { value: outline, error: outlineError } = outlineState;\n    /**\n     * Called when an outline is read successfully\n     */\n    function onLoadSuccess() {\n        if (typeof outline === 'undefined' || outline === false) {\n            return;\n        }\n        if (onLoadSuccessProps) {\n            onLoadSuccessProps(outline);\n        }\n    }\n    /**\n     * Called when an outline failed to read successfully\n     */\n    function onLoadError() {\n        if (!outlineError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning(false, outlineError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(outlineError);\n        }\n    }\n    function resetOutline() {\n        outlineDispatch({ type: 'RESET' });\n    }\n    useEffect(resetOutline, [outlineDispatch, pdf]);\n    function loadOutline() {\n        if (!pdf) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        const cancellable = makeCancellable(pdf.getOutline());\n        const runningTask = cancellable;\n        cancellable.promise\n            .then((nextOutline) => {\n            outlineDispatch({ type: 'RESOLVE', value: nextOutline });\n        })\n            .catch((error) => {\n            outlineDispatch({ type: 'REJECT', error });\n        });\n        return () => cancelRunningTask(runningTask);\n    }\n    useEffect(loadOutline, [outlineDispatch, pdf]);\n    useEffect(() => {\n        if (outline === undefined) {\n            return;\n        }\n        if (outline === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, \n    // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [outline]);\n    const childContext = useMemo(() => ({\n        onItemClick,\n    }), [onItemClick]);\n    const eventProps = useMemo(() => makeEventProps(otherProps, () => outline), [otherProps, outline]);\n    if (!outline) {\n        return null;\n    }\n    function renderOutline() {\n        if (!outline) {\n            return null;\n        }\n        return (React.createElement(\"ul\", null, outline.map((item, itemIndex) => (React.createElement(OutlineItem, { key: typeof item.dest === 'string' ? item.dest : itemIndex, item: item })))));\n    }\n    return (React.createElement(\"div\", Object.assign({ className: clsx('react-pdf__Outline', className), ref: inputRef }, eventProps),\n        React.createElement(OutlineContext.Provider, { value: childContext }, renderOutline())));\n};\nOutline.propTypes = Object.assign(Object.assign({}, eventProps), { className: isClassName, inputRef: isRef, onItemClick: PropTypes.func, onLoadError: PropTypes.func, onLoadSuccess: PropTypes.func, pdf: isPdf });\nexport default Outline;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}